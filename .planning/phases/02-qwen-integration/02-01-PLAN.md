---
phase: 02-qwen-integration
type: execute
domain: external-api
---

<objective>
Set up DashScope Qwen image generation API integration through PocketBase backend proxy.

Purpose: Establish the API integration layer that enables the frontend to communicate with Alibaba's DashScope image generation service while handling CORS, authentication, and async task polling.
Output: Working backend proxy endpoint, frontend API client, and React hook for image generation with polling.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qwen-integration/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**Tech stack available:**
- React 18.3.1 with TypeScript 5.6.2 (from Phase 1)
- PocketBase SDK 0.26.5 (from Phase 1)
- Vite 6.0.1 with HMR (from Phase 1)
- Tailwind CSS v4 with dark mode (from Phase 1)

**Established patterns:**
- PocketBase singleton at http://127.0.0.1:8090 (from Phase 1)
- Path alias @/ → ./src (from Phase 1)
- Project structure: components/, lib/, hooks/ (from Phase 1)

**Constraining decisions:**
- Phase 1: PocketBase singleton pattern must be used for backend proxy
- Phase 1: Path alias @/ configured for clean imports
- RESEARCH.md: Backend proxy required (CORS blocks direct browser calls)
- RESEARCH.md: Use Qwen-Image-Plus for simplicity (0.2 RMB/image, Beijing region)
- RESEARCH.md: Async pattern required (image generation takes 1-2 minutes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PocketBase backend proxy endpoint</name>
  <files>pb_data/hooks/extend.go, .env</files>
  <action>
Create PocketBase Go extension that proxies requests to DashScope API:

1. Create `pb_data/hooks/extend.go` with Go code that:
   - Registers OnBeforeServe hook
   - Adds POST endpoint at `/api/qwen/generate`
   - Reads request body: { prompt: string, size?: string }
   - Calls DashScope API with:
     * URL: https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation
     * Headers: Authorization: Bearer $DASHSCOPE_API_KEY, X-DashScope-Async: enable
     * Body: { model: "qwen-image-plus", input: { messages: [{ role: "user", content: [{ text: prompt }] }] }, parameters: { size: size || "1328*1328" } }
   - Returns DashScope response (including task_id)

2. Create `.env` file with:
   - DASHSCOPE_API_KEY=sk-your-key-here
   - DASHSCOPE_REGION=beijing

IMPORTANT: Use Go http.NewRequest() not curl. Parse JSON body with echo.Context#Bind(). Return raw JSON response from DashScope without modification in this task (error handling comes later).

WHY NOT use Node.js/Express proxy: PocketBase already installed, simpler for personal tool, no additional infrastructure needed.
  </action>
  <verify>
- `pb_data/hooks/extend.go` exists and compiles without errors
- `.env` exists with DASHSCOPE_API_KEY placeholder
- Start PocketBase with `./pocketbase serve` (if not running)
- Test endpoint: `curl -X POST http://127.0.0.1:8090/api/qwen/generate -H "Content-Type: application/json" -d '{"prompt":"test"}'` returns 200 or 401 (auth error expected without real key)
  </verify>
  <done>
PocketBase proxy endpoint created and accessible. Endpoint accepts POST requests at /api/qwen/generate, forwards to DashScope API, returns task_id.
</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend API client</name>
  <files>src/lib/qwen-api.ts</files>
  <action>
Create TypeScript API client for calling PocketBase proxy:

```typescript
// src/lib/qwen-api.ts
import pb from './pocketbase';

export interface GenerateImageOptions {
  size?: '1024*1024' | '1328*1328' | '1920*1080';
  promptExtend?: boolean;
  watermark?: boolean;
}

export interface GenerateImageResponse {
  output: {
    task_id: string;
    task_status: 'PENDING' | 'RUNNING' | 'SUCCEEDED' | 'FAILED';
  };
  request_id: string;
}

export async function generateImage(
  prompt: string,
  options: GenerateImageOptions = {}
): Promise<GenerateImageResponse> {
  const result = await pb.send('/api/qwen/generate', {
    method: 'POST',
    body: JSON.stringify({
      prompt,
      size: options.size || '1328*1328',
      prompt_extend: options.promptExtend !== false,
      watermark: options.watermark || false
    })
  });

  return result as GenerateImageResponse;
}

export interface TaskResult {
  output: {
    task_id: string;
    task_status: 'PENDING' | 'RUNNING' | 'SUCCEEDED' | 'FAILED';
    choices?: Array<{
      message: {
        content: Array<{ image: string; type: string }>;
      };
    }>;
  };
}

export async function getTaskResult(taskId: string): Promise<TaskResult> {
  const result = await pb.send(`/api/qwen/task/${taskId}`, {
    method: 'GET'
  });

  return result as TaskResult;
}
```

WHY THIS STRUCTURE: Matches DashScope API response format exactly. Type definitions ensure compile-time safety. Functions are async to handle network requests.

NOTE: Task result endpoint doesn't exist yet - implemented in Task 1's proxy (add GET /api/qwen/task/:taskId route that forwards to DashScope's GET /api/v1/tasks/{task_id}).
  </action>
  <verify>
- `src/lib/qwen-api.ts` exists with exports: generateImage, getTaskResult
- TypeScript compilation passes: `npx tsc --noEmit`
- Imports work: `import { generateImage } from '@/lib/qwen-api'` resolves correctly
  </verify>
  <done>
Frontend API client created with types and async functions. Client can call PocketBase proxy endpoint and get typed responses.
</done>
</task>

<task type="auto">
  <name>Task 3: Create React hook for async polling</name>
  <files>src/hooks/useImageGeneration.ts</files>
  <action>
Create React hook that manages the full image generation workflow with polling:

```typescript
// src/hooks/useImageGeneration.ts
import { useState, useCallback, useRef } from 'react';
import { generateImage, getTaskResult, GenerateImageOptions } from '@/lib/qwen-api';

type GenerationStatus = 'idle' | 'pending' | 'processing' | 'succeeded' | 'failed';

export function useImageGeneration() {
  const [status, setStatus] = useState<GenerationStatus>('idle');
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [taskId, setTaskId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const pollIntervalRef = useRef<number | null>(null);

  const clearPoll = useCallback(() => {
    if (pollIntervalRef.current) {
      clearInterval(pollIntervalRef.current);
      pollIntervalRef.current = null;
    }
  }, []);

  const generate = useCallback(async (prompt: string, options?: GenerateImageOptions) => {
    try {
      setStatus('pending');
      setImageUrl(null);
      setTaskId(null);
      setError(null);

      // Step 1: Create task
      const response = await generateImage(prompt, options);
      setTaskId(response.output.task_id);
      setStatus('processing');

      // Step 2: Poll for result
      pollIntervalRef.current = window.setInterval(async () => {
        try {
          const result = await getTaskResult(response.output.task_id);
          const { task_status } = result.output;

          if (task_status === 'SUCCEEDED') {
            const url = result.output.choices?.[0]?.message?.content?.[0]?.image;
            if (url) {
              setImageUrl(url);
              setStatus('succeeded');
            } else {
              setStatus('failed');
              setError('No image URL in response');
            }
            clearPoll();
          } else if (task_status === 'FAILED') {
            setStatus('failed');
            setError('Task failed');
            clearPoll();
          }
          // Continue polling for PENDING and RUNNING
        } catch (err) {
          setStatus('failed');
          setError(err instanceof Error ? err.message : 'Polling error');
          clearPoll();
        }
      }, 5000); // Poll every 5 seconds
    } catch (err) {
      setStatus('failed');
      setError(err instanceof Error ? err.message : 'Generation failed');
      clearPoll();
    }
  }, [clearPoll]);

  // Cleanup on unmount
  const cleanup = useCallback(() => {
    clearPoll();
    setStatus('idle');
    setImageUrl(null);
    setTaskId(null);
    setError(null);
  }, [clearPoll]);

  return { generate, status, imageUrl, taskId, error, cleanup };
}
```

KEY IMPLEMENTATION DETAILS:
- Polling every 5 seconds (per DashScope docs recommendation)
- Cleanup interval on unmount or completion
- Returns all state for UI to render loading/error/success
- Type-safe with TypeScript

WHY polling not WebSockets: DashScope doesn't support WebSocket callbacks in HTTP API. Polling is the standard pattern.

WHY 5 second interval: DashScope docs recommend 5-10 second polling. 5 seconds provides good balance between responsiveness and API load.
  </action>
  <verify>
- `src/hooks/useImageGeneration.ts` exists with useImageGeneration export
- TypeScript compilation passes: `npx tsc --noEmit`
- Hook interface correct: returns { generate, status, imageUrl, taskId, error, cleanup }
  </verify>
  <done>
React hook created with polling logic. Hook manages full workflow: create task → poll every 5s → update status → return image URL on success. Cleanup prevents memory leaks.
</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] PocketBase server starts without errors: `./pocketbase serve`
- [ ] Backend proxy endpoint accessible: `curl -X POST http://127.0.0.1:8090/api/qwen/generate`
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] No import errors in src/lib/qwen-api.ts or src/hooks/useImageGeneration.ts
- [ ] All exports work correctly when imported in App.tsx
</verification>

<success_criteria>

- PocketBase backend proxy endpoint created at /api/qwen/generate
- Frontend API client wraps PocketBase calls with proper TypeScript types
- React hook implements async polling pattern with 5-second intervals
- All code compiles without TypeScript errors
- Hook provides clean API: { generate, status, imageUrl, taskId, error, cleanup }
  </success_criteria>

<output>
After completion, create `.planning/phases/02-qwen-integration/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Qwen Integration Summary

**DashScope API integration with PocketBase backend proxy**

## Accomplishments

- PocketBase Go extension created with /api/qwen/generate endpoint
- Frontend TypeScript API client with proper types
- React hook with async polling (5-second intervals)
- Full workflow: create task → poll → return image URL

## Files Created/Modified

- `pb_data/hooks/extend.go` - PocketBase Go extension with proxy endpoint
- `.env` - DashScope API key configuration
- `src/lib/qwen-api.ts` - Frontend API client with types
- `src/hooks/useImageGeneration.ts` - React hook for polling workflow

## Decisions Made

- **Qwen-Image-Plus model**: Chosen for simplicity and pricing (0.2 RMB/image)
- **Beijing region**: Default for China deployment with free tier
- **5-second polling**: Balance between responsiveness and API load
- **PocketBase over Express**: Simpler for personal tool, already installed

## Issues Encountered

[None anticipated - following documented patterns from RESEARCH.md]

## Next Step

Ready for Phase 3: Generation UI (prompt input and generate button)
</output>
