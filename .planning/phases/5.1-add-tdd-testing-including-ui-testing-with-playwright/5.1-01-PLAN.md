---
phase: 5.1-add-tdd-testing-including-ui-testing-with-playwright
plan: 01
type: execute
domain: testing
---

<objective>
Set up test framework infrastructure with Vitest for unit/integration tests and Playwright for E2E UI testing.

Purpose: Establish testing foundation that enables TDD for all future development and validates existing error handling, API integration, and React components.
Output: Configured Vitest with test runner, Playwright with browser testing, test scripts in package.json, and example tests demonstrating framework capabilities.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phases with relevant context:
@.planning/phases/02-qwen-integration/02-01-SUMMARY.md
@.planning/phases/03-generation-ui/03-01-SUMMARY.md
@.planning/phases/05-error-handling/05-01-SUMMARY.md

# Source files to be tested:
@src/lib/errors.ts
@src/lib/qwen-api.ts
@src/hooks/useImageGeneration.ts
@src/components/ui/PromptInput.tsx
@src/components/ui/GenerateButton.tsx

**Tech stack available:**
- React 18.3.1 with TypeScript 5.6.2
- Vite 6.4.1 build system
- Existing component patterns (controlled components, custom hooks)
- Error handling with ParsedError interface

**Established patterns:**
- Type-safe error parsing with ErrorCode enum
- React hooks with useState, useCallback, useRef patterns
- Props interfaces for UI components
- Tailwind v4 for styling

**Constraining decisions:**
- Phase 1: Tailwind CSS v4 CSS-first approach (no tailwind.config.js)
- Phase 2: TypeScript-first development with proper interfaces
- Phase 3: Controlled component pattern for React state
- Phase 5: ParsedError interface for error handling

**Current issues to address:**
- No test framework exists
- Need to validate error parsing logic works correctly
- Need to test retry logic with exponential backoff
- Need E2E tests for image generation workflow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Vitest for unit/integration tests</name>
  <files>package.json, vite.config.ts, src/lib/errors.test.ts, src/lib/setupTests.ts</files>
  <action>
Install Vitest as test framework:
1. Run: `npm install -D vitest @vitest/ui jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event`
2. Create vitest.config.ts with:
   - test match pattern: **/*.test.ts
   - environment: jsdom for DOM testing
   - globals: true for global test APIs
   - setupFiles: './src/lib/setupTests.ts'
3. Create src/lib/setupTests.ts with @testing-library auto-cleanup
4. Add test scripts to package.json:
   - "test": "vitest"
   - "test:ui": "vitest --ui"
   - "test:run": "vitest run"
5. Create example test src/lib/errors.test.ts to verify setup works

WHY Vitest over Jest:
- Vitest is Vite-native (faster, same config)
- Better TypeScript support
- ESM module support (Jest has CommonJS issues)
- Compatible with Vite HMR for faster dev feedback

WHY jsdom environment:
- Allows testing React components without browser
- Faster than Playwright for unit tests
- Provides window, document, navigator globals
  </action>
  <verify>
1. `npm install -D vitest @vitest/ui jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event` succeeds
2. `npx vitest --version` shows version
3. `npx vitest run` passes with 1 example test
4. `npx vitest --ui` launches UI at http://localhost:51204/__vitest__/
  </verify>
  <done>
Vitest installed and configured, example test passes, UI accessible
</done>
</task>

<task type="auto">
  <name>Task 2: Install and configure Playwright for E2E UI testing</name>
  <files>package.json, playwright.config.ts, tests/e2e/image-generation.spec.ts</files>
  <action>
Install Playwright for browser testing:
1. Run: `npm install -D @playwright/test`
2. Run: `npx playwright install` to install browsers
3. Create playwright.config.ts with:
   - Use: vite to use Vite's config
   - WebServer: command: 'npm run dev', port: 5173, timeout: 120 * 1000
   - Test dir: tests/e2e
   - FullyParallel: false (sequential for API rate limits)
4. Add E2E test script to package.json:
   - "test:e2e": "playwright test"
   - "test:e2e:ui": "playwright test --ui"
5. Create example E2E test tests/e2e/example.spec.ts

WHY Playwright over Cypress:
- Better TypeScript support
- Faster execution
- Multi-browser support (Chrome, Firefox, Safari)
- Better for Vite apps (Cypress has ESM issues)
- Network mocking for API calls

WHY sequential execution:
- Image generation has rate limits
- Parallel tests would exceed DashScope API limits
- Sequential tests are slower but safer for quota
  </action>
  <verify>
1. `npm install -D @playwright/test` succeeds
2. `npx playwright --version` shows version
3. `npx playwright install` installs chromium, firefox, webkit
4. `npx playwright test` runs example test successfully
5. `npx playwright test --ui` launches Playwright UI
  </verify>
  <done>
Playwright installed with browsers, example E2E test passes, UI accessible
</done>
</task>

<task type="auto">
  <name>Task 3: Create test utilities and mock helpers</name>
  <files>src/test-utils/mocks.ts, src/test-utils/test-helpers.tsx</files>
  <action>
Create testing utilities for consistent tests:
1. Create src/test-utils/mocks.ts with:
   - mockDashScopeSuccessResponse() - returns successful API response
   - mockDashScopeErrorResponse() - returns error response with status code
   - mockParsedError() - returns ParsedError object for testing
   - mockTaskResult() - returns TaskResult with various statuses
2. Create src/test-utils/test-helpers.tsx with:
   - renderWithProviders() - custom render with React Testing Library
   - waitForStatus() - helper to wait for useImageGeneration status changes
   - mockGenerateImage() - MSW mock or similar for API mocking
3. Export all utilities from src/test-utils/index.ts

WHY test utilities:
- Consistent mocking across all tests
- DRY principle - avoid repeating mock setup
- Easy to update mocks when API changes
- Single source of truth for test data

NOTE: For now, create simple mock objects. MSW (Mock Service Worker) integration can be added in Plan 2 if needed for complex API mocking.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors in test utils)
2. Imports work: `import { mockDashScopeSuccessResponse } from '@/test-utils/mocks'`
3. Mock functions return expected data structure
4. All exports from index.ts are accessible
  </verify>
  <done>
Test utilities created, TypeScript compiles, mock helpers functional
</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Vitest installed and configured (vitest.config.ts exists)
- [ ] Playwright installed and configured (playwright.config.ts exists)
- [ ] `npm test` runs Vitest successfully
- [ ] `npm run test:e2e` runs Playwright successfully
- [ ] Example tests pass in both frameworks
- [ ] Test scripts added to package.json
- [ ] TypeScript compilation passes: `npx tsc --noEmit`
- [ ] All test utilities are properly typed
</verification>

<success_criteria>

- Vitest framework installed and configured for unit/integration tests
- Playwright framework installed and configured for E2E UI tests
- Test utilities and mock helpers created
- Example tests demonstrate framework capabilities
- All test scripts work (test, test:ui, test:e2e, test:e2e:ui)
- TypeScript compilation passes
- Ready for Plan 2: Write unit/integration tests
  </success_criteria>

<output>
After completion, create `.planning/phases/5.1-add-tdd-testing-including-ui-testing-with-playwright/5.1-01-SUMMARY.md`:

# Phase 5.1 Plan 1: Test Framework Setup Summary

**Vitest and Playwright configured with test utilities and example tests**

## Accomplishments

- Installed Vitest for unit/integration testing with jsdom environment
- Installed Playwright for E2E UI testing with browser automation
- Created test utilities and mock helpers for consistent testing
- Added test scripts to package.json for all test workflows
- Verified frameworks work with example tests

## Files Created/Modified

- `package.json` - Added test dependencies and scripts
- `vitest.config.ts` - Vitest configuration with jsdom environment
- `playwright.config.ts` - Playwright configuration with Vite integration
- `src/lib/setupTests.ts` - Testing Library setup with auto-cleanup
- `src/lib/errors.test.ts` - Example Vitest test
- `tests/e2e/example.spec.ts` - Example Playwright test
- `src/test-utils/mocks.ts` - Mock helpers for API responses and errors
- `src/test-utils/test-helpers.tsx` - React Testing Library utilities
- `src/test-utils/index.ts` - Test utilities exports

## Decisions Made

- **Vitest over Jest** - Vite-native, faster, better TypeScript/ESM support
- **Playwright over Cypress** - Better TS support, faster, multi-browser, Vite-compatible
- **jsdom environment** - Fast DOM testing without browser overhead
- **Sequential E2E execution** - Prevents API rate limit issues
- **Test utilities pattern** - DRY mocking, consistent test data, single source of truth

## Issues Encountered

None - framework setup followed established patterns.

## Next Step

Ready for Plan 2: Write unit/integration tests for error parsing, API client, and React hooks
</output>
