---
phase: 05-error-handling
type: execute
domain: frontend-ui
---

<objective>
Implement comprehensive error handling for API failures, rate limits, and user feedback.

Purpose: Transform raw API errors into helpful user messages, add resilience through retry logic, and enable debugging through centralized logging.
Output: Enhanced error parsing, user-friendly error messages, automatic retry for transient failures, and console error logging for debugging.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qwen-integration/02-RESEARCH.md
@.planning/phases/02-qwen-integration/02-01-SUMMARY.md
@.planning/phases/03-generation-ui/03-01-SUMMARY.md

**Tech stack available:**
- React 18.3.1 with TypeScript 5.6.2 (from Phase 1)
- DashScope API error codes documented in Phase 2 research
- Vite dev server with proxy configuration (from Phase 3)
- useImageGeneration hook with error state (from Phase 2)

**Established patterns:**
- Error state in React hooks: useState<string | null> (from Phase 2)
- Error display in UI components (from Phase 3)
- TypeScript interfaces for API responses (from Phase 2)
- Tailwind v4 styling for error messages (from Phase 1)

**Constraining decisions:**
- Phase 2: DashScope API returns JSON with code/message/request_id fields
- Phase 2: Common errors: InvalidApiKey, DataInspectionFailed, RateLimit, QuotaExceeded
- Phase 2: Image generation takes 1-2 minutes (timeout considerations)
- Phase 3: Error display exists but shows raw error messages
- PROJECT.md: Core value is simple workflow - errors should be actionable and clear

**Current issues to address:**
- User seeing "API error: 400 Bad Request" without explanation
- No retry logic for transient network failures
- No differentiation between user errors (invalid prompt) and system errors (API down)
- No helpful suggestions when errors occur
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error type utilities and parser</name>
  <files>src/lib/errors.ts</files>
  <action>
Create error parsing utilities to transform DashScope API errors into user-friendly messages:

```typescript
// src/lib/errors.ts

// DashScope API error response structure
interface DashScopeErrorResponse {
  code: string;
  message: string;
  request_id: string;
}

export enum ErrorCode {
  // Authentication errors
  INVALID_API_KEY = 'InvalidApiKey',
  AUTH_FAILED = 'AuthFailed',

  // Rate limiting
  RATE_LIMIT_EXCEEDED = 'RateLimitExceeded',
  QUOTA_EXCEEDED = 'QuotaExceeded',

  // Content errors
  CONTENT_MODERATION_FAILED = 'DataInspectionFailed',
  INVALID_REQUEST = 'InvalidRequest',

  // Task errors
  TASK_NOT_FOUND = 'TaskNotFound',
  TASK_FAILED = 'TaskFailed',

  // Network/system errors
  NETWORK_ERROR = 'NetworkError',
  TIMEOUT = 'Timeout',
  UNKNOWN = 'Unknown'
}

export interface ParsedError {
  code: ErrorCode;
  userMessage: string;
  technicalMessage: string;
  suggestion: string;
  isRetryable: boolean;
}

// Map DashScope error codes to user-friendly messages
const ERROR_MESSAGES: Record<string, Omit<ParsedError, 'code' | 'technicalMessage'>> = {
  [ErrorCode.INVALID_API_KEY]: {
    userMessage: 'API key is invalid or missing',
    suggestion: 'Check your .env file and ensure DASHSCOPE_API_KEY is set correctly',
    isRetryable: false
  },
  [ErrorCode.RATE_LIMIT_EXCEEDED]: {
    userMessage: 'Too many requests - rate limit exceeded',
    suggestion: 'Wait a few minutes before trying again',
    isRetryable: true
  },
  [ErrorCode.QUOTA_EXCEEDED]: {
    userMessage: 'API quota exceeded - no more generations available',
    suggestion: 'Check your Alibaba Cloud account to add more quota',
    isRetryable: false
  },
  [ErrorCode.CONTENT_MODERATION_FAILED]: {
    userMessage: 'Prompt blocked by content moderation',
    suggestion: 'Try rephrasing your prompt. Avoid sensitive or inappropriate content.',
    isRetryable: false
  },
  [ErrorCode.INVALID_REQUEST]: {
    userMessage: 'Invalid request format',
    suggestion: 'This is likely a bug - please report it',
    isRetryable: false
  },
  [ErrorCode.TASK_NOT_FOUND]: {
    userMessage: 'Task not found - it may have expired',
    suggestion: 'Try generating the image again',
    isRetryable: true
  },
  [ErrorCode.TASK_FAILED]: {
    userMessage: 'Image generation failed on the server',
    suggestion: 'Try a different prompt or check the DashScope console for details',
    isRetryable: true
  }
};

// Parse DashScope API error response
export function parseAPIError(errorText: string, statusCode: number): ParsedError {
  try {
    const errorJson: DashScopeErrorResponse = JSON.parse(errorText);
    const code = errorJson.code || ErrorCode.UNKNOWN;
    const mapped = ERROR_MESSAGES[code] || {
      userMessage: errorJson.message || 'Unknown error',
      suggestion: 'Try again or contact support',
      isRetryable: false
    };

    const parsed = {
      code: code as ErrorCode,
      technicalMessage: errorJson.message,
      ...mapped
    };

    // Log error for debugging and AI analysis
    console.error('[API Error]', {
      timestamp: new Date().toISOString(),
      statusCode,
      errorCode: code,
      userMessage: parsed.userMessage,
      technicalMessage: parsed.technicalMessage,
      suggestion: parsed.suggestion,
      isRetryable: parsed.isRetryable,
      rawResponse: errorJson,
      action: parsed.isRetryable ? 'will retry with backoff' : 'will show to user'
    });

    return parsed;
  } catch {
    // JSON parse failed - likely not a DashScope error
    let parsed: ParsedError;

    if (statusCode === 401) {
      parsed = {
        code: ErrorCode.AUTH_FAILED,
        userMessage: 'Authentication failed',
        technicalMessage: 'Unauthorized',
        suggestion: 'Check your API key configuration',
        isRetryable: false
      };
    } else if (statusCode === 429) {
      parsed = {
        code: ErrorCode.RATE_LIMIT_EXCEEDED,
        userMessage: 'Too many requests',
        technicalMessage: errorText,
        suggestion: 'Wait a few minutes before trying again',
        isRetryable: true
      };
    } else if (statusCode >= 500) {
      parsed = {
        code: ErrorCode.UNKNOWN,
        userMessage: 'Server error - DashScope API is having issues',
        technicalMessage: errorText,
        suggestion: 'Try again in a few minutes',
        isRetryable: true
      };
    } else {
      parsed = {
        code: ErrorCode.UNKNOWN,
        userMessage: `Request failed (${statusCode})`,
        technicalMessage: errorText,
        suggestion: 'Check your internet connection and try again',
        isRetryable: false
      };
    }

    // Log non-JSON error for debugging and AI analysis
    console.error('[API Error]', {
      timestamp: new Date().toISOString(),
      statusCode,
      errorCode: parsed.code,
      userMessage: parsed.userMessage,
      technicalMessage: parsed.technicalMessage,
      suggestion: parsed.suggestion,
      isRetryable: parsed.isRetryable,
      rawResponse: errorText,
      parseError: 'Failed to parse as JSON',
      action: parsed.isRetryable ? 'will retry with backoff' : 'will show to user'
    });

    return parsed;
  }
}

// Parse network/timeout errors
export function parseNetworkError(err: unknown): ParsedError {
  let parsed: ParsedError;

  if (err instanceof Error) {
    if (err.name === 'AbortError' || err.message.includes('timeout')) {
      parsed = {
        code: ErrorCode.TIMEOUT,
        userMessage: 'Request timed out',
        technicalMessage: err.message,
        suggestion: 'Check your internet connection and try again',
        isRetryable: true
      };
    } else if (err.message.includes('fetch')) {
      parsed = {
        code: ErrorCode.NETWORK_ERROR,
        userMessage: 'Network error - could not reach the API',
        technicalMessage: err.message,
        suggestion: 'Check your internet connection',
        isRetryable: true
      };
    } else {
      parsed = {
        code: ErrorCode.UNKNOWN,
        userMessage: 'An unexpected error occurred',
        technicalMessage: err.message,
        suggestion: 'Try refreshing the page',
        isRetryable: false
      };
    }
  } else {
    parsed = {
      code: ErrorCode.UNKNOWN,
      userMessage: 'An unexpected error occurred',
      technicalMessage: err instanceof Error ? err.message : 'Unknown error',
      suggestion: 'Try refreshing the page',
      isRetryable: false
    };
  }

  // Log network error for debugging and AI analysis
  console.error('[Network Error]', {
    timestamp: new Date().toISOString(),
    errorCode: parsed.code,
    userMessage: parsed.userMessage,
    technicalMessage: parsed.technicalMessage,
    suggestion: parsed.suggestion,
    isRetryable: parsed.isRetryable,
    originalError: err instanceof Error ? { name: err.name, message: err.message } : err,
    action: parsed.isRetryable ? 'will retry with backoff' : 'will show to user'
  });

  return parsed;
}
```

WHY this structure:
- ErrorCode enum provides type-safe error categorization
- ERROR_MESSAGES map centralizes user-facing strings
- parseAPIError handles DashScope-specific error format
- parseNetworkError handles browser fetch failures
- isRetryable flag enables automatic retry logic in Task 2
- console.error() logging enables debugging in browser console

AI-Optimized Logging:
- All logs include timestamp for chronological ordering
- Structured objects (not strings) for easy parsing
- Complete context: error code, user/technical messages, suggestions
- "action" field describes what will happen next
- "rawResponse" preserves original API response for deep debugging
- Consistent field names across all log types

NOTE: Error codes based on Phase 2 RESEARCH.md "Common Pitfalls" section.
  Console logs use [API Error] and [Network Error] prefixes for easy filtering in browser DevTools.
  When sharing console logs with AI agents, include the full object output for best analysis.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- Exports work: `import { parseAPIError, ErrorCode } from '@/lib/errors'`
- All ErrorCode enum values have ERROR_MESSAGES entries
  </verify>
  <done>
Error type utilities created with parser for DashScope API errors and network errors.
</done>
</task>

<task type="auto">
  <name>Task 2: Add retry logic to useImageGeneration hook</name>
  <files>src/hooks/useImageGeneration.ts</files>
  <action>
Add retry logic with exponential backoff for transient failures:

1. Update imports to include parseAPIError and parseNetworkError
2. Add MAX_RETRIES constant and retry state
3. Wrap generateImage and getTaskResult calls in retry logic

```typescript
// src/hooks/useImageGeneration.ts
import { useState, useCallback, useRef } from 'react';
import { generateImage, getTaskResult, GenerateImageOptions } from '@/lib/qwen-api';
import { parseAPIError, parseNetworkError, type ParsedError } from '@/lib/errors';

const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 2000; // 2 seconds
const RETRY_BACKOFF = 1.5; // 1.5x multiplier

export type GenerationStatus = 'idle' | 'pending' | 'processing' | 'succeeded' | 'failed';

export function useImageGeneration() {
  const [status, setStatus] = useState<GenerationStatus>('idle');
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [taskId, setTaskId] = useState<string | null>(null);
  const [error, setError] = useState<ParsedError | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const pollIntervalRef = useRef<number | null>(null);
  const taskIdRef = useRef<string | null>(null);

  const clearPoll = useCallback(() => {
    if (pollIntervalRef.current) {
      clearInterval(pollIntervalRef.current);
      pollIntervalRef.current = null;
    }
  }, []);

  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

  // Helper function to retry with exponential backoff
  const retryWithBackoff = async <T>(
    fn: () => Promise<T>,
    retries = MAX_RETRIES,
    delay = INITIAL_RETRY_DELAY
  ): Promise<T> => {
    try {
      return await fn();
    } catch (err) {
      if (retries <= 0) throw err;

      const parsedError = err instanceof Error && 'message' in err
        ? parseNetworkError(err)
        : parseAPIError(String(err), 0);

      // Only retry retryable errors
      if (!parsedError.isRetryable) {
        throw parsedError;
      }

      const attemptNumber = MAX_RETRIES - retries + 1;

      // Log retry attempt for debugging and AI analysis
      console.log('[Retry]', {
        timestamp: new Date().toISOString(),
        attempt: attemptNumber,
        maxRetries: MAX_RETRIES,
        remainingRetries: retries - 1,
        delay: `${delay}ms`,
        backoffMultiplier: RETRY_BACKOFF,
        errorCode: parsedError.code,
        userMessage: parsedError.userMessage,
        technicalMessage: parsedError.technicalMessage,
        suggestion: parsedError.suggestion,
        action: `waiting ${delay}ms before retry ${attemptNumber + 1}/${MAX_RETRIES}`
      });

      // Show retry status to user
      setError(parsedError);
      setStatus('processing'); // Keep processing status

      // Wait before retry
      await sleep(delay);

      // Retry with exponential backoff
      return retryWithBackoff(fn, retries - 1, delay * RETRY_BACKOFF);
    }
  };

  const generate = useCallback(async (prompt: string, options?: GenerateImageOptions) => {
    try {
      setStatus('pending');
      setImageUrl(null);
      setTaskId(null);
      setError(null);
      setRetryCount(0);

      // Step 1: Create task with retry logic
      const response = await retryWithBackoff(async () => {
        return await generateImage(prompt, options);
      });

      const currentTaskId = response.output.task_id;
      taskIdRef.current = currentTaskId;
      setTaskId(currentTaskId);
      setError(null); // Clear retry errors if successful
      setStatus('processing');

      // Log task creation success for debugging and AI analysis
      console.log('[Image Generation]', {
        timestamp: new Date().toISOString(),
        phase: 'task_created',
        taskId: currentTaskId,
        status: 'PENDING',
        prompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''),
        promptLength: prompt.length,
        options: options,
        action: 'starting async task, will poll for results',
        expectedDuration: '1-2 minutes'
      });

      // Step 2: Poll for result with retry logic
      pollIntervalRef.current = window.setInterval(async () => {
        try {
          const result = await retryWithBackoff(async () => {
            return await getTaskResult(currentTaskId);
          });

          const { task_status } = result.output;

          if (task_status === 'SUCCEEDED') {
            const url = result.output.choices?.[0]?.message?.content?.[0]?.image;
            if (url) {
              setImageUrl(url);
              setStatus('succeeded');
              setError(null);

              // Log success for debugging and AI analysis
              console.log('[Image Generation]', {
                timestamp: new Date().toISOString(),
                phase: 'task_succeeded',
                taskId: currentTaskId,
                status: 'SUCCEEDED',
                imageUrl: url,
                action: 'image generation completed successfully, displaying to user'
              });
            } else {
              setStatus('failed');
              setError({
                code: 'Unknown' as any,
                userMessage: 'No image URL in response',
                technicalMessage: 'Task succeeded but no image found',
                suggestion: 'Try generating again',
                isRetryable: true
              });

              // Log missing image URL for debugging and AI analysis
              console.error('[Image Generation]', {
                timestamp: new Date().toISOString(),
                phase: 'task_succeeded_no_image',
                taskId: currentTaskId,
                status: 'SUCCEEDED',
                error: 'Task succeeded but no image URL in response',
                action: 'will show error to user suggesting retry'
              });
            }
            clearPoll();
          } else if (task_status === 'FAILED') {
            setStatus('failed');
            setError({
              code: 'TaskFailed' as any,
              userMessage: 'Image generation failed on the server',
              technicalMessage: 'Task marked as FAILED by DashScope',
              suggestion: 'Try a different prompt',
              isRetryable: true
            });

            // Log task failure for debugging and AI analysis
            console.error('[Image Generation]', {
              timestamp: new Date().toISOString(),
              phase: 'task_failed',
              taskId: currentTaskId,
              status: 'FAILED',
              error: 'Task marked as FAILED by DashScope API',
              action: 'will show error to user suggesting different prompt'
            });

            clearPoll();
          }
        } catch (err) {
          const parsedError = err instanceof Error
            ? parseNetworkError(err)
            : parseAPIError(String(err), 0);

          setStatus('failed');
          setError(parsedError);

          // Log polling error for debugging and AI analysis
          console.error('[Image Generation - Polling Error]', {
            timestamp: new Date().toISOString(),
            phase: 'polling_failed',
            taskId: currentTaskId,
            error: parsedError,
            action: 'will show error to user, stopping polling'
          });

          clearPoll();
        }
      }, 5000); // Poll every 5 seconds
    } catch (err) {
      const parsedError = err instanceof Error
        ? parseNetworkError(err)
        : parseAPIError(String(err), 0);

      setStatus('failed');
      setError(parsedError);

      // Log task creation failure for debugging and AI analysis
      console.error('[Image Generation - Failed]', {
        timestamp: new Date().toISOString(),
        phase: 'task_creation_failed',
        prompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''),
        promptLength: prompt.length,
        options: options,
        error: parsedError,
        action: 'all retries exhausted, will show error to user'
      });

      clearPoll();
    }
  }, [clearPoll]);

  // Cleanup on unmount
  const cleanup = useCallback(() => {
    clearPoll();
    setStatus('idle');
    setImageUrl(null);
    setTaskId(null);
    setError(null);
    setRetryCount(0);
  }, [clearPoll]);

  return { generate, status, imageUrl, taskId, error, cleanup };
}
```

WHY exponential backoff: Prevents overwhelming the API during outages, increases delay between retries (2s â†’ 3s â†’ 4.5s).

WHY retry on 5xx errors: Server errors are often transient, worth retrying. 4xx errors (except rate limits) are user errors and should not retry.

WHY show retry errors: User sees what's happening during retries ("Rate limit exceeded, waiting...") rather than silent failures.

AI-Optimized Logging:
- All logs include timestamp for chronological ordering
- "phase" field tracks operation lifecycle (task_created, task_succeeded, task_failed, polling_failed)
- "action" field explains what happens next in plain language
- Complete context: taskId, prompt (truncated), options, error details
- Retry logs include attempt count, remaining retries, delay, backoff multiplier
- Structured objects enable AI agents to trace complete request flow

NOTE: Only retries errors where isRetryable=true (network issues, server errors, rate limits).
  Console logs include taskId, prompt (truncated to 100 chars), options, and error details for debugging.
  When sharing logs with AI, include the full [Image Generation] and [Retry] log sequences for complete trace.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- All imports resolve correctly
- Returns ParsedError instead of string for error state
- Cleanup clears retry count
  </verify>
  <done>
Retry logic added with exponential backoff for transient failures. Hook now returns ParsedError object instead of string.
</done>
</task>

<task type="auto">
  <name>Task 3: Update UI to show user-friendly error messages</name>
  <files>src/App.tsx</files>
  <action>
Update App.tsx error display to show parsed error messages with suggestions:

1. Update error handling to work with ParsedError objects
2. Display user-friendly error messages
3. Show suggestions when errors occur
4. Add retry button for retryable errors
5. Log errors when displayed to user for debugging

First, add a useEffect to log when errors are displayed (add after the hook declarations):

```typescript
import { useEffect } from 'react';

// ... inside App component, after hook declarations

// Log errors when displayed to user for debugging and AI analysis
useEffect(() => {
  if (error) {
    console.warn('[UI Error Displayed]', {
      timestamp: new Date().toISOString(),
      errorCode: error.code,
      userMessage: error.userMessage,
      technicalMessage: error.technicalMessage,
      suggestion: error.suggestion,
      isRetryable: error.isRetryable,
      currentStatus: status,
      willShowRetryButton: error.isRetryable && status === 'failed',
      action: 'showing error message to user in UI'
    });
  }
}, [error, status]);
```

Then replace the error display section in App.tsx:

```typescript
{/* Error display */}
{error && (
  <div className="mt-4 p-4 rounded-lg bg-destructive/10 border border-destructive text-destructive">
    <div className="flex items-start gap-3">
      <div className="flex-shrink-0">
        <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
        </svg>
      </div>
      <div className="flex-1">
        <p className="font-semibold">Error: {error.userMessage}</p>
        {error.suggestion && (
          <p className="text-sm mt-1 opacity-90">ðŸ’¡ {error.suggestion}</p>
        )}
        {error.isRetryable && status === 'failed' && (
          <button
            onClick={() => {
              if (prompt.trim()) {
                setError(null);
                generate(prompt, { size: '1328*1328' });
              }
            }}
            className="mt-2 px-3 py-1 text-sm rounded bg-destructive text-destructive-foreground hover:opacity-90"
          >
            Try Again
          </button>
        )}
      </div>
    </div>
  </div>
)}
```

WHY suggestion with emoji: Makes error messages feel more helpful and less scary. ðŸ’¡ emoji indicates a helpful tip.

WHY retry button: Allows users to quickly retry without re-entering prompt. Only shown for retryable errors (rate limits, network issues).

WHY technical message hidden: Most users don't need technical details. userMessage is what matters. suggestion provides actionable next step.

AI-Optimized Logging:
- useEffect with console.warn tracks when errors reach the UI
- "willShowRetryButton" field indicates if retry UI is present
- "action" field confirms error is being displayed to user
- Complete error context: code, messages, suggestion, retryable status
- Timestamps help correlate with earlier [API Error] and [Retry] logs
- Enables AI agents to verify error handling flow: API â†’ retry â†’ UI display

Also update the type declaration at the top of App.tsx:

```typescript
function App() {
  const [prompt, setPrompt] = useState('');
  const [darkMode, setDarkMode] = useState(false);
  const { generate, status, imageUrl, taskId, error, cleanup } = useImageGeneration();
  // ... rest of component
```

No other changes needed - error state is now ParsedError object instead of string.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- Error message displays user-friendly text
- Suggestion shows when available
- Retry button appears for retryable errors
- "Try Again" button works and re-triggers generation
- Console shows [UI Error Displayed] warning when errors are shown
- Console log includes error code, user message, suggestion, and retryable status
  </verify>
  <done>
UI updated to show user-friendly error messages with suggestions, retry functionality, and console logging for debugging.
</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] TypeScript compiles: `npx tsc --noEmit` passes
- [ ] All new files created (src/lib/errors.ts)
- [ ] Error parsing handles DashScope API errors
- [ ] Error parsing handles network errors
- [ ] Retry logic implemented with exponential backoff
- [ ] UI shows user-friendly messages
- [ ] Retry button works for retryable errors
- [ ] Console logs appear for API errors ([API Error] prefix)
- [ ] Console logs appear for network errors ([Network Error] prefix)
- [ ] Console logs appear for retry attempts ([Retry Attempt] prefix)
- [ ] Console logs appear for image generation lifecycle ([Image Generation] prefix)
- [ ] Console warnings appear when errors are displayed to users ([UI Error Displayed] prefix)
</verification>

<success_criteria>

- Error type utilities created with ErrorCode enum and parsers
- Retry logic with exponential backoff (2s â†’ 3s â†’ 4.5s delays)
- Only retries retryable errors (rate limits, network, server errors)
- UI shows user-friendly messages instead of raw API errors
- Suggestions provide actionable next steps
- Retry button allows quick retry without re-entering prompt
- AI-optimized console logging for debugging and agent analysis:
  - All logs include ISO timestamps for chronological ordering
  - Structured objects (not strings) for programmatic parsing
  - "action" field describes next step in plain language
  - "phase" field tracks operation lifecycle
  - Complete context preserved (raw responses, error codes, prompts)
  - Consistent field names across all log types
- Log prefixes for easy filtering:
  - [API Error] - DashScope API errors with status codes and raw responses
  - [Network Error] - Browser fetch/timeout errors
  - [Retry] - Retry attempts with delays, backoff multipliers, remaining attempts
  - [Image Generation] - Task lifecycle (creation, success, failure, polling)
  - [UI Error Displayed] - Errors shown to users with retry button status
- All TypeScript compilation passes
  </success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Error Handling Summary

**Comprehensive error handling with retry logic, user-friendly messages, and console logging**

## Accomplishments

- Created error type utilities with ErrorCode enum and parsers
- Added retry logic with exponential backoff for transient failures
- Transformed raw API errors into helpful user messages
- Added actionable suggestions for common errors
- Implemented retry button for quick recovery
- Added comprehensive console logging for debugging with prefixed messages

## Files Created/Modified

- `src/lib/errors.ts` - Error parsing utilities and ErrorCode enum with console logging
- `src/hooks/useImageGeneration.ts` - Added retry logic with exponential backoff and lifecycle logging
- `src/App.tsx` - Updated error display with user-friendly messages and UI logging

## Decisions Made

- **Exponential backoff** - 2s â†’ 3s â†’ 4.5s delays prevent API overload
- **Selective retry** - Only retry retryable errors (not user errors like invalid prompts)
- **Error messages first** - Show user-friendly text, hide technical details
- **Actionable suggestions** - Every error includes specific next steps
- **Quick retry button** - Allows immediate retry without re-entering prompt
- **AI-optimized logging** - Structured objects with timestamps, "action" field, "phase" field, and complete context for agent analysis

## Issues Encountered

None - all tasks completed following established patterns.

## Next Step

Ready for Phase 6: Polish (loading states, responsiveness, refinements)
</output>
