---
phase: 5.1-add-tdd-testing-including-ui-testing-with-playwright
plan: 02
type: tdd
domain: testing
---

<objective>
Write unit and integration tests for error handling, API integration, and React hooks following TDD principles.

Purpose: Validate core business logic with comprehensive test coverage, ensure error parsing works correctly for all DashScope error codes, verify retry logic with exponential backoff, and confirm React hook behavior.
Output: Tested error parsing utilities, tested API client functions, tested React hook with mock data, and high test coverage (>80%) for core logic.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phases with implementation details:
@.planning/phases/02-qwen-integration/02-01-SUMMARY.md
@.planning/phases/05-error-handling/05-01-SUMMARY.md
@.planning/phases/5.1-add-tdd-testing-including-ui-testing-with-playwright/5.1-01-SUMMARY.md

# Source files to test:
@src/lib/errors.ts
@src/lib/qwen-api.ts
@src/hooks/useImageGeneration.ts

# Test utilities from Plan 1:
@src/test-utils/mocks.ts
@src/test-utils/test-helpers.tsx

**Tech stack available:**
- Vitest with jsdom environment (from Plan 1)
- React Testing Library (from Plan 1)
- Test utilities and mock helpers (from Plan 1)
- TypeScript for type-safe tests

**Established patterns:**
- ParsedError interface with userMessage, technicalMessage, suggestion, isRetryable
- ErrorCode enum for all DashScope error types
- Exponential backoff with 2s → 3s → 4.5s delays
- MAX_RETRIES=3, RETRY_BACKOFF=1.5

**Constraining decisions:**
- Phase 5: All errors must be retryable or non-retryable based on type
- Phase 5: Console logging with structured objects and ISO timestamps
- Phase 2: Async task polling every 5 seconds
- Phase 3: Controlled component pattern with useState

**What needs testing:**
- parseAPIError() handles all DashScope error codes correctly
- parseNetworkError() handles fetch/timeout errors
- Retry logic respects isRetryable flag
- Exponential backoff delays are correct (2s, 3s, 4.5s)
- useImageGeneration hook state transitions work correctly
- Error states are set and cleared appropriately
</context>

<tasks>

<task type="tdd" tdd="true">
  <name>Task 1: Test error parsing utilities (parseAPIError and parseNetworkError)</name>
  <files>src/lib/errors.test.ts</files>
  <behavior>
Test error parsing functions transform raw errors into ParsedError objects:

1. parseAPIError(errorText, statusCode) should:
   - Parse DashScope JSON error responses correctly
   - Map error codes to user-friendly messages
   - Return ParsedError with correct fields (code, userMessage, technicalMessage, suggestion, isRetryable)
   - Handle non-JSON responses (fallback to status code parsing)
   - Log errors with [API Error] prefix to console

2. parseNetworkError(err) should:
   - Handle AbortError/timeout errors (isRetryable: true)
   - Handle fetch failures (isRetryable: true)
   - Handle unknown errors (isRetryable: false)
   - Return ParsedError with structured fields
   - Log errors with [Network Error] prefix to console

Test cases:
- InvalidApiKey → userMessage: "API key is invalid or missing", isRetryable: false
- RateLimitExceeded → userMessage: "Too many requests", isRetryable: true
- QuotaExceeded → userMessage: "API quota exceeded", isRetryable: false
- DataInspectionFailed → userMessage: "Prompt blocked by content moderation", isRetryable: false
- Timeout error → isRetryable: true
- Network error → isRetryable: true
- Unknown error → isRetryable: false
  </behavior>
  <implementation>
Use Vitest describe() and test() blocks:
1. Import parseAPIError, parseNetworkError, ErrorCode, ParsedError
2. Mock console.error to verify logging without spamming output
3. Test each ErrorCode enum value maps correctly
4. Test non-JSON fallback (e.g., 401 without JSON body)
5. Test network errors (AbortError, fetch errors)
6. Verify console.error is called with correct prefix and fields

Use expect() assertions:
- expect(parsedError.code).toBe(ErrorCode.INVALID_API_KEY)
- expect(parsedError.userMessage).toBe("API key is invalid or missing")
- expect(parsedError.isRetryable).toBe(false)
- expect(console.error).toHaveBeenCalledWith("[API Error]", expect.objectContaining({...}))
  </implementation>
</task>

<task type="tdd" tdd="true">
  <name>Task 2: Test retry logic with exponential backoff</name>
  <files>src/hooks/useImageGeneration.test.ts</files>
  <behavior>
Test retryWithBackoff helper function:
1. Should retry retryable errors up to MAX_RETRIES (3 times)
2. Should not retry non-retryable errors
3. Should use exponential backoff delays: 2s → 3s → 4.5s
4. Should log retry attempts with [Retry] prefix
5. Should throw error after exhausting retries
6. Should return result immediately on success

Test scenarios:
- Success on first try → returns result, no retries
- Retryable error (RateLimitExceeded) → retries 3 times with backoff
- Non-retryable error (InvalidApiKey) → throws immediately, no retries
- Network timeout → retries 3 times
- After 3 failed retries → throws error
  </behavior>
  <implementation>
Test retry logic with mocked promises:
1. Create test helper that tracks call count and delays
2. Mock sleep() function to avoid actual delays in tests
3. Mock parseAPIError/parseNetworkError to control retry behavior
4. Test with vi.useFakeTimers() to verify delay timing
5. Verify console.log called with [Retry] prefix and correct attempt numbers

Example test structure:
```typescript
it('should retry retryable errors 3 times with exponential backoff', async () => {
  vi.useFakeTimers();
  const mockFn = vi.fn()
    .mockRejectedValueOnce(new Error('Rate limit'))
    .mockRejectedValueOnce(new Error('Rate limit'))
    .mockResolvedValueOnce('success');

  const result = await retryWithBackoff(mockFn);
  expect(result).toBe('success');
  expect(mockFn).toHaveBeenCalledTimes(3);
});
```
  </implementation>
</task>

<task type="tdd" tdd="true">
  <name>Task 3: Test useImageGeneration hook state management</name>
  <files>src/hooks/useImageGeneration.test.tsx</files>
  <behavior>
Test React hook behavior:
1. Initial state should be: status='idle', imageUrl=null, taskId=null, error=null
2. generate(prompt, options) should:
   - Set status to 'pending' immediately
   - Call generateImage API
   - Set taskId and status to 'processing' on success
   - Start polling for task result
   - Set imageUrl and status to 'succeeded' on task completion
   - Set error and status to 'failed' on API failure
3. cleanup() should clear all state and stop polling
4. Error state should be ParsedError object (not string)
5. Hook should handle retry logic automatically

Test scenarios:
- Idle state initially
- Pending state after calling generate()
- Processing state after task creation
- Success state after image generated
- Failed state with error object
- Cleanup clears all state
  </behavior>
  <implementation>
Test React hook with @testing-library/react-hooks:
1. Import { renderHook, act, waitFor } from '@testing-library/react'
2. Mock generateImage and getTaskResult from '@/lib/qwen-api'
3. Mock parseAPIError and parseNetworkError from '@/lib/errors'
4. Test initial state with renderHook(() => useImageGeneration())
5. Test generate() triggers state changes with act()
6. Test cleanup() clears state with act()
7. Use waitFor() for async state updates

Example test structure:
```typescript
it('should transition from idle to pending to processing to succeeded', async () => {
  const { result } = renderHook(() => useImageGeneration());

  expect(result.current.status).toBe('idle');

  await act(async () => {
    await result.current.generate('test prompt');
  });

  expect(result.current.status).toBe('processing');
  // ... continue testing
});
```
  </implementation>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All tests pass: `npm test` succeeds
- [ ] Test coverage >80% for src/lib/errors.ts
- [ ] Test coverage >80% for src/hooks/useImageGeneration.ts
- [ ] All error code paths tested
- [ ] Retry logic tested with various error scenarios
- [ ] Hook state transitions tested
- [ ] Console logging verified with mock spies
- [ ] No TypeScript errors
</verification>

<success_criteria>

- parseAPIError() tested for all DashScope error codes
- parseNetworkError() tested for timeout, fetch, and unknown errors
- Retry logic tested with exponential backoff timing
- useImageGeneration hook state transitions fully tested
- Test coverage >80% for error parsing and hook logic
- All tests pass: `npm test`
- TDD cycle completed: RED → GREEN → (optional REFACTOR)
  </success_criteria>

<output>
After completion, create `.planning/phases/5.1-add-tdd-testing-including-ui-testing-with-playwright/5.1-02-SUMMARY.md`:

# Phase 5.1 Plan 2: Unit/Integration Tests Summary

**Comprehensive test coverage for error parsing, retry logic, and React hooks with TDD approach**

## Accomplishments

- Tested parseAPIError() for all DashScope error codes (10+ error types)
- Tested parseNetworkError() for timeout, fetch, and unknown errors
- Tested retry logic with exponential backoff (2s → 3s → 4.5s delays)
- Tested useImageGeneration hook state transitions (idle → pending → processing → succeeded/failed)
- Achieved >80% test coverage for core business logic
- Verified console logging with mock spies

## Files Created/Modified

- `src/lib/errors.test.ts` - Comprehensive error parsing tests
- `src/hooks/useImageGeneration.test.tsx` - Hook behavior and state management tests

## Commits

1. **test(5.1-02): add failing test for error parsing** - RED
2. **feat(5.1-02): implement error parsing tests** - GREEN
3. **test(5.1-02): add failing test for retry logic** - RED
4. **feat(5.1-02): implement retry logic tests** - GREEN
5. **test(5.1-02): add failing test for hook state** - RED
6. **feat(5.1-02): implement hook state tests** - GREEN
7. **refactor(5.1-02): extract test helpers (optional)** - REFACTOR

## Decisions Made

- **TDD approach** - Write failing tests first, implement to pass, refactor if needed
- **Mock console.error** - Avoid spamming test output, verify logging with spies
- **Fake timers** - Use vi.useFakeTimers() to test delays without waiting
- **@testing-library/react-hooks** - Test hooks without rendering full components
- **Separate test files** - One test file per source file for organization

## Issues Encountered

None - TDD cycle worked smoothly for all test suites.

## Next Phase Readiness

- Core business logic fully tested
- Error handling validated for all DashScope error codes
- Retry logic verified with exponential backoff
- Ready for Plan 3: E2E UI tests with Playwright
</output>
