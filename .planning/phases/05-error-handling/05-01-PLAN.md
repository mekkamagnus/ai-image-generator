---
phase: 05-error-handling
type: execute
domain: frontend-ui
---

<objective>
Implement comprehensive error handling for API failures, rate limits, and user feedback.

Purpose: Transform raw API errors into helpful user messages and add resilience through retry logic.
Output: Enhanced error parsing, user-friendly error messages, and automatic retry for transient failures.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-qwen-integration/02-RESEARCH.md
@.planning/phases/02-qwen-integration/02-01-SUMMARY.md
@.planning/phases/03-generation-ui/03-01-SUMMARY.md

**Tech stack available:**
- React 18.3.1 with TypeScript 5.6.2 (from Phase 1)
- DashScope API error codes documented in Phase 2 research
- Vite dev server with proxy configuration (from Phase 3)
- useImageGeneration hook with error state (from Phase 2)

**Established patterns:**
- Error state in React hooks: useState<string | null> (from Phase 2)
- Error display in UI components (from Phase 3)
- TypeScript interfaces for API responses (from Phase 2)
- Tailwind v4 styling for error messages (from Phase 1)

**Constraining decisions:**
- Phase 2: DashScope API returns JSON with code/message/request_id fields
- Phase 2: Common errors: InvalidApiKey, DataInspectionFailed, RateLimit, QuotaExceeded
- Phase 2: Image generation takes 1-2 minutes (timeout considerations)
- Phase 3: Error display exists but shows raw error messages
- PROJECT.md: Core value is simple workflow - errors should be actionable and clear

**Current issues to address:**
- User seeing "API error: 400 Bad Request" without explanation
- No retry logic for transient network failures
- No differentiation between user errors (invalid prompt) and system errors (API down)
- No helpful suggestions when errors occur
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error type utilities and parser</name>
  <files>src/lib/errors.ts</files>
  <action>
Create error parsing utilities to transform DashScope API errors into user-friendly messages:

```typescript
// src/lib/errors.ts

// DashScope API error response structure
interface DashScopeErrorResponse {
  code: string;
  message: string;
  request_id: string;
}

export enum ErrorCode {
  // Authentication errors
  INVALID_API_KEY = 'InvalidApiKey',
  AUTH_FAILED = 'AuthFailed',

  // Rate limiting
  RATE_LIMIT_EXCEEDED = 'RateLimitExceeded',
  QUOTA_EXCEEDED = 'QuotaExceeded',

  // Content errors
  CONTENT_MODERATION_FAILED = 'DataInspectionFailed',
  INVALID_REQUEST = 'InvalidRequest',

  // Task errors
  TASK_NOT_FOUND = 'TaskNotFound',
  TASK_FAILED = 'TaskFailed',

  // Network/system errors
  NETWORK_ERROR = 'NetworkError',
  TIMEOUT = 'Timeout',
  UNKNOWN = 'Unknown'
}

export interface ParsedError {
  code: ErrorCode;
  userMessage: string;
  technicalMessage: string;
  suggestion: string;
  isRetryable: boolean;
}

// Map DashScope error codes to user-friendly messages
const ERROR_MESSAGES: Record<string, Omit<ParsedError, 'code' | 'technicalMessage'>> = {
  [ErrorCode.INVALID_API_KEY]: {
    userMessage: 'API key is invalid or missing',
    suggestion: 'Check your .env file and ensure DASHSCOPE_API_KEY is set correctly',
    isRetryable: false
  },
  [ErrorCode.RATE_LIMIT_EXCEEDED]: {
    userMessage: 'Too many requests - rate limit exceeded',
    suggestion: 'Wait a few minutes before trying again',
    isRetryable: true
  },
  [ErrorCode.QUOTA_EXCEEDED]: {
    userMessage: 'API quota exceeded - no more generations available',
    suggestion: 'Check your Alibaba Cloud account to add more quota',
    isRetryable: false
  },
  [ErrorCode.CONTENT_MODERATION_FAILED]: {
    userMessage: 'Prompt blocked by content moderation',
    suggestion: 'Try rephrasing your prompt. Avoid sensitive or inappropriate content.',
    isRetryable: false
  },
  [ErrorCode.INVALID_REQUEST]: {
    userMessage: 'Invalid request format',
    suggestion: 'This is likely a bug - please report it',
    isRetryable: false
  },
  [ErrorCode.TASK_NOT_FOUND]: {
    userMessage: 'Task not found - it may have expired',
    suggestion: 'Try generating the image again',
    isRetryable: true
  },
  [ErrorCode.TASK_FAILED]: {
    userMessage: 'Image generation failed on the server',
    suggestion: 'Try a different prompt or check the DashScope console for details',
    isRetryable: true
  }
};

// Parse DashScope API error response
export function parseAPIError(errorText: string, statusCode: number): ParsedError {
  try {
    const errorJson: DashScopeErrorResponse = JSON.parse(errorText);
    const code = errorJson.code || ErrorCode.UNKNOWN;
    const mapped = ERROR_MESSAGES[code] || {
      userMessage: errorJson.message || 'Unknown error',
      suggestion: 'Try again or contact support',
      isRetryable: false
    };

    return {
      code: code as ErrorCode,
      technicalMessage: errorJson.message,
      ...mapped
    };
  } catch {
    // JSON parse failed - likely not a DashScope error
    if (statusCode === 401) {
      return {
        code: ErrorCode.AUTH_FAILED,
        userMessage: 'Authentication failed',
        technicalMessage: 'Unauthorized',
        suggestion: 'Check your API key configuration',
        isRetryable: false
      };
    }

    if (statusCode === 429) {
      return {
        code: ErrorCode.RATE_LIMIT_EXCEEDED,
        userMessage: 'Too many requests',
        technicalMessage: errorText,
        suggestion: 'Wait a few minutes before trying again',
        isRetryable: true
      };
    }

    if (statusCode >= 500) {
      return {
        code: ErrorCode.UNKNOWN,
        userMessage: 'Server error - DashScope API is having issues',
        technicalMessage: errorText,
        suggestion: 'Try again in a few minutes',
        isRetryable: true
      };
    }

    return {
      code: ErrorCode.UNKNOWN,
      userMessage: `Request failed (${statusCode})`,
      technicalMessage: errorText,
      suggestion: 'Check your internet connection and try again',
      isRetryable: false
    };
  }
}

// Parse network/timeout errors
export function parseNetworkError(err: unknown): ParsedError {
  if (err instanceof Error) {
    if (err.name === 'AbortError' || err.message.includes('timeout')) {
      return {
        code: ErrorCode.TIMEOUT,
        userMessage: 'Request timed out',
        technicalMessage: err.message,
        suggestion: 'Check your internet connection and try again',
        isRetryable: true
      };
    }

    if (err.message.includes('fetch')) {
      return {
        code: ErrorCode.NETWORK_ERROR,
        userMessage: 'Network error - could not reach the API',
        technicalMessage: err.message,
        suggestion: 'Check your internet connection',
        isRetryable: true
      };
    }
  }

  return {
    code: ErrorCode.UNKNOWN,
    userMessage: 'An unexpected error occurred',
    technicalMessage: err instanceof Error ? err.message : 'Unknown error',
    suggestion: 'Try refreshing the page',
    isRetryable: false
  };
}
```

WHY this structure:
- ErrorCode enum provides type-safe error categorization
- ERROR_MESSAGES map centralizes user-facing strings
- parseAPIError handles DashScope-specific error format
- parseNetworkError handles browser fetch failures
- isRetryable flag enables automatic retry logic in Task 2

NOTE: Error codes based on Phase 2 RESEARCH.md "Common Pitfalls" section.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- Exports work: `import { parseAPIError, ErrorCode } from '@/lib/errors'`
- All ErrorCode enum values have ERROR_MESSAGES entries
  </verify>
  <done>
Error type utilities created with parser for DashScope API errors and network errors.
</done>
</task>

<task type="auto">
  <name>Task 2: Add retry logic to useImageGeneration hook</name>
  <files>src/hooks/useImageGeneration.ts</files>
  <action>
Add retry logic with exponential backoff for transient failures:

1. Update imports to include parseAPIError and parseNetworkError
2. Add MAX_RETRIES constant and retry state
3. Wrap generateImage and getTaskResult calls in retry logic

```typescript
// src/hooks/useImageGeneration.ts
import { useState, useCallback, useRef } from 'react';
import { generateImage, getTaskResult, GenerateImageOptions } from '@/lib/qwen-api';
import { parseAPIError, parseNetworkError, type ParsedError } from '@/lib/errors';

const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 2000; // 2 seconds
const RETRY_BACKOFF = 1.5; // 1.5x multiplier

export type GenerationStatus = 'idle' | 'pending' | 'processing' | 'succeeded' | 'failed';

export function useImageGeneration() {
  const [status, setStatus] = useState<GenerationStatus>('idle');
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [taskId, setTaskId] = useState<string | null>(null);
  const [error, setError] = useState<ParsedError | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const pollIntervalRef = useRef<number | null>(null);
  const taskIdRef = useRef<string | null>(null);

  const clearPoll = useCallback(() => {
    if (pollIntervalRef.current) {
      clearInterval(pollIntervalRef.current);
      pollIntervalRef.current = null;
    }
  }, []);

  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

  // Helper function to retry with exponential backoff
  const retryWithBackoff = async <T>(
    fn: () => Promise<T>,
    retries = MAX_RETRIES,
    delay = INITIAL_RETRY_DELAY
  ): Promise<T> => {
    try {
      return await fn();
    } catch (err) {
      if (retries <= 0) throw err;

      const parsedError = err instanceof Error && 'message' in err
        ? parseNetworkError(err)
        : parseAPIError(String(err), 0);

      // Only retry retryable errors
      if (!parsedError.isRetryable) {
        throw parsedError;
      }

      // Show retry status to user
      setError(parsedError);
      setStatus('processing'); // Keep processing status

      // Wait before retry
      await sleep(delay);

      // Retry with exponential backoff
      return retryWithBackoff(fn, retries - 1, delay * RETRY_BACKOFF);
    }
  };

  const generate = useCallback(async (prompt: string, options?: GenerateImageOptions) => {
    try {
      setStatus('pending');
      setImageUrl(null);
      setTaskId(null);
      setError(null);
      setRetryCount(0);

      // Step 1: Create task with retry logic
      const response = await retryWithBackoff(async () => {
        return await generateImage(prompt, options);
      });

      const currentTaskId = response.output.task_id;
      taskIdRef.current = currentTaskId;
      setTaskId(currentTaskId);
      setError(null); // Clear retry errors if successful
      setStatus('processing');

      // Step 2: Poll for result with retry logic
      pollIntervalRef.current = window.setInterval(async () => {
        try {
          const result = await retryWithBackoff(async () => {
            return await getTaskResult(currentTaskId);
          });

          const { task_status } = result.output;

          if (task_status === 'SUCCEEDED') {
            const url = result.output.choices?.[0]?.message?.content?.[0]?.image;
            if (url) {
              setImageUrl(url);
              setStatus('succeeded');
              setError(null);
            } else {
              setStatus('failed');
              setError({
                code: 'Unknown' as any,
                userMessage: 'No image URL in response',
                technicalMessage: 'Task succeeded but no image found',
                suggestion: 'Try generating again',
                isRetryable: true
              });
            }
            clearPoll();
          } else if (task_status === 'FAILED') {
            setStatus('failed');
            setError({
              code: 'TaskFailed' as any,
              userMessage: 'Image generation failed on the server',
              technicalMessage: 'Task marked as FAILED by DashScope',
              suggestion: 'Try a different prompt',
              isRetryable: true
            });
            clearPoll();
          }
        } catch (err) {
          const parsedError = err instanceof Error
            ? parseNetworkError(err)
            : parseAPIError(String(err), 0);

          setStatus('failed');
          setError(parsedError);
          clearPoll();
        }
      }, 5000); // Poll every 5 seconds
    } catch (err) {
      const parsedError = err instanceof Error
        ? parseNetworkError(err)
        : parseAPIError(String(err), 0);

      setStatus('failed');
      setError(parsedError);
      clearPoll();
    }
  }, [clearPoll]);

  // Cleanup on unmount
  const cleanup = useCallback(() => {
    clearPoll();
    setStatus('idle');
    setImageUrl(null);
    setTaskId(null);
    setError(null);
    setRetryCount(0);
  }, [clearPoll]);

  return { generate, status, imageUrl, taskId, error, cleanup };
}
```

WHY exponential backoff: Prevents overwhelming the API during outages, increases delay between retries (2s â†’ 3s â†’ 4.5s).

WHY retry on 5xx errors: Server errors are often transient, worth retrying. 4xx errors (except rate limits) are user errors and should not retry.

WHY show retry errors: User sees what's happening during retries ("Rate limit exceeded, waiting...") rather than silent failures.

NOTE: Only retries errors where isRetryable=true (network issues, server errors, rate limits).
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- All imports resolve correctly
- Returns ParsedError instead of string for error state
- Cleanup clears retry count
  </verify>
  <done>
Retry logic added with exponential backoff for transient failures. Hook now returns ParsedError object instead of string.
</done>
</task>

<task type="auto">
  <name>Task 3: Update UI to show user-friendly error messages</name>
  <files>src/App.tsx</files>
  <action>
Update App.tsx error display to show parsed error messages with suggestions:

1. Update error handling to work with ParsedError objects
2. Display user-friendly error messages
3. Show suggestions when errors occur
4. Add retry button for retryable errors

Replace the error display section in App.tsx:

```typescript
{/* Error display */}
{error && (
  <div className="mt-4 p-4 rounded-lg bg-destructive/10 border border-destructive text-destructive">
    <div className="flex items-start gap-3">
      <div className="flex-shrink-0">
        <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
        </svg>
      </div>
      <div className="flex-1">
        <p className="font-semibold">Error: {error.userMessage}</p>
        {error.suggestion && (
          <p className="text-sm mt-1 opacity-90">ðŸ’¡ {error.suggestion}</p>
        )}
        {error.isRetryable && status === 'failed' && (
          <button
            onClick={() => {
              if (prompt.trim()) {
                setError(null);
                generate(prompt, { size: '1328*1328' });
              }
            }}
            className="mt-2 px-3 py-1 text-sm rounded bg-destructive text-destructive-foreground hover:opacity-90"
          >
            Try Again
          </button>
        )}
      </div>
    </div>
  </div>
)}
```

WHY suggestion with emoji: Makes error messages feel more helpful and less scary. ðŸ’¡ emoji indicates a helpful tip.

WHY retry button: Allows users to quickly retry without re-entering prompt. Only shown for retryable errors (rate limits, network issues).

WHY technical message hidden: Most users don't need technical details. userMessage is what matters. suggestion provides actionable next step.

Also update the type declaration at the top of App.tsx:

```typescript
function App() {
  const [prompt, setPrompt] = useState('');
  const [darkMode, setDarkMode] = useState(false);
  const { generate, status, imageUrl, taskId, error, cleanup } = useImageGeneration();
  // ... rest of component
```

No other changes needed - error state is now ParsedError object instead of string.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit` passes
- Error message displays user-friendly text
- Suggestion shows when available
- Retry button appears for retryable errors
- "Try Again" button works and re-triggers generation
  </verify>
  <done>
UI updated to show user-friendly error messages with suggestions and retry functionality.
</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] TypeScript compiles: `npx tsc --noEmit` passes
- [ ] All new files created (src/lib/errors.ts)
- [ ] Error parsing handles DashScope API errors
- [ ] Error parsing handles network errors
- [ ] Retry logic implemented with exponential backoff
- [ ] UI shows user-friendly messages
- [ ] Retry button works for retryable errors
</verification>

<success_criteria>

- Error type utilities created with ErrorCode enum and parsers
- Retry logic with exponential backoff (2s â†’ 3s â†’ 4.5s delays)
- Only retries retryable errors (rate limits, network, server errors)
- UI shows user-friendly messages instead of raw API errors
- Suggestions provide actionable next steps
- Retry button allows quick retry without re-entering prompt
- All TypeScript compilation passes
  </success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Error Handling Summary

**Comprehensive error handling with retry logic and user-friendly messages**

## Accomplishments

- Created error type utilities with ErrorCode enum and parsers
- Added retry logic with exponential backoff for transient failures
- Transformed raw API errors into helpful user messages
- Added actionable suggestions for common errors
- Implemented retry button for quick recovery

## Files Created/Modified

- `src/lib/errors.ts` - Error parsing utilities and ErrorCode enum
- `src/hooks/useImageGeneration.ts` - Added retry logic with exponential backoff
- `src/App.tsx` - Updated error display with user-friendly messages

## Decisions Made

- **Exponential backoff** - 2s â†’ 3s â†’ 4.5s delays prevent API overload
- **Selective retry** - Only retry retryable errors (not user errors like invalid prompts)
- **Error messages first** - Show user-friendly text, hide technical details
- **Actionable suggestions** - Every error includes specific next steps
- **Quick retry button** - Allows immediate retry without re-entering prompt

## Issues Encountered

None - all tasks completed following established patterns.

## Next Step

Ready for Phase 6: Polish (loading states, responsiveness, refinements)
</output>
